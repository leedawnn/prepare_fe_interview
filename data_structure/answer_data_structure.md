# prepare_frontend_interview

## 자료구조

### 프론트엔드 기술 면접을 위한 핸드북 만들기

공부하고 알아야 할 만한 기본적인 자료구조에 대해 정리합니다

python으로 작성된 코드의 예시들이 있지만, JS와는 큰 차이가 없기 때문에 예시 코드로는 파이썬을 넣어 두었습니다

대학 정규 교육 과정으로 오랜 기간 공부해서 배운 내용이 아니기 때문에 깊이 면에서 부족할 수 있지만,

자료구조와 그에 따른 예시를 간단히 작성하여 자료 구조는 어떤 것들이 있는지 알기 위해 정리하고 있습니다

## 목차

- [prepare\_frontend\_interview](#prepare_frontend_interview)
  - [자료구조](#자료구조)
    - [프론트엔드 기술 면접을 위한 핸드북 만들기](#프론트엔드-기술-면접을-위한-핸드북-만들기)
  - [목차](#목차)
    - [자료구조란 무엇인가요](#자료구조란-무엇인가요)
    - [대표적인 자료구조는 어떤 것들이 있나요](#대표적인-자료구조는-어떤-것들이-있나요)
    - [자바스크립트의 자료 구조](#자바스크립트의-자료-구조)
    - [배열](#배열)
    - [큐](#큐)
    - [스택](#스택)
    - [링크드 리스트](#링크드-리스트)
    - [해시 테이블](#해시-테이블)
    - [트리](#트리)
      - [이진 트리(Binary Tree)와 이진 탐색트리(Binary Search Tree)](#이진-트리binary-tree와-이진-탐색트리binary-search-tree)
    - [그래프](#그래프)
    - [힙](#힙)
  - [내가 뽑은 핵심 질문](#내가-뽑은-핵심-질문)

---

### 자료구조란 무엇인가요

- 자료구조란 대량의 데이터를 효율적으로 관리할 수 있는 데이터 구조를 의미합니다. 코드 상에서 효율적으로 데이터를 처리하기 위해, 데이터 특성에 따라 체계적으로 데이터를 구조화해야 합니다.

### 대표적인 자료구조는 어떤 것들이 있나요

- **선형 구조(Linear Structure)** : 데이터들이 일렬로 쭉 저장되어 있는 형태
  - 리스트(List) => 선형 리스트(Linear List), 연결 리스트(Linked List) / 스택(Stack) / 큐(Queue) / 데크(Deque)
- **비 선형 구조(Non-Linear Structure)** : 데이터가 트리 형태로 저장되어 있다고 생각하고 사용하는 자료구조
  - 트리(Tree) / 그래프(Graph)

### 자바스크립트의 자료 구조

![](https://res.cloudinary.com/practicaldev/image/fetch/s--_nqttmjZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.hashnode.com/res/hashnode/image/upload/v1619611250125/8tZFEKg3Y.png)

### 배열

- 배열(Array)은 가장 기본적인 데이터 구조입니다. Java나 C언어와는 다르게 동적 배열을 가지고 있기 때문에 배열 내부의 데이터 타입이 서로 다를 수 있고, 배열의 크기는 동적으로 변경될 수 있습니다.

  ```javascript
  // 서로 다른 데이터 타입을 담을 수 있다
  const arr = [1234, 'test', true];
  ```

- 자바스크립트의 배열은 변수 외에도 객체와 함수도 담을 수 있고, 배열이 생성되면 배열의 크기는 임의로 변경이 가능하며 이미 할당된 값은 사라지지 않습니다. 자바스크립트의 배열은 제약사항이 적어서 자유롭게 사용할 수 있지만 사용 시 많은 주의를 기울여야 합니다.

### 큐

![](https://res.cloudinary.com/practicaldev/image/fetch/s--I2JzCIZt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.hashnode.com/res/hashnode/image/upload/v1619612564546/wKa7IZvmD.png)

- 큐는 FIFO(First In First Out) 원칙을 따르는 선형 데이터 구조입니다. 1) **front pointer**, 2) **rear pointer** 2개의 포인터가 있습니다. front pointer는 시작 요소의 주소가 포함되고, rear pointer에는 대기열의 마지막 요소의 주소가 포함됩니다. 큐의 구현에 사용되는 두 가지 주요 방법은 **enqueue**와 **dequeue** 방법입니다. Enqueuing은 큐에 요소를 추가하는 프로세스이고, dequeuing은 큐에서 요소를 제거하는 프로세스입니다.
- **어디에 큐가 많이 쓰일까?**
  - 멀티 태스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 많이 사용됩니다.

### 스택

![](https://res.cloudinary.com/practicaldev/image/fetch/s--ZQVb0uUv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.hashnode.com/res/hashnode/image/upload/v1619525079548/nmLn6pEVy.jpeg)

- 스택은 LIFO(Last In First Out) 또는 FILO(First In Last Out) 원리를 따르는 선형 데이터 구조입니다. 여기에는 스택의 맨 위 요소를 가리키는 스택 포인터가 하나만 포함됩니다. 스택에 요소를 추가할 때마다 스택의 맨 위에 추가되며 스택에서 요소를 삭제할 때마다 스택의 맨 위에서 삭제됩니다. `push()`로 스택에 데이터를 넣고, `pop()`으로 스택에 들어있는 데이터를 빼내는 작업을 구현합니다.
- **어디에 스택이 많이 쓰일까?**
  - 컴퓨터 내부의 프로세스 구조의 함수 동작 방식

### 링크드 리스트

![](https://res.cloudinary.com/practicaldev/image/fetch/s--gukqRKbB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.hashnode.com/res/hashnode/image/upload/v1619623950414/hFovrOEhj.png)

- 링크드 리스트는 선형 데이터 구조입니다. 노드 그룹으로 구성되며 각 노드는 고유한 데이터와 다음 노드에 대한 주소를 가집니다. Array에서는 요소가 인덱싱되고 즉시 요소로 이동할 수 있지만, 링크드 리스트는 head에서부터 시작하여 원하는 요소로 이동할 때까지 계속 진행해야 합니다. 링크드 리스트의 장점은 배열의 요소가 연속된 위치에 저장되기 때문에 연결된 목록의 삽입 및 삭제가 Array보다 쉽다는 것입니다. 또한 링크드 리스트의 크기가 요구사항에 따라 증가하거나 축소될 수 있기 때문에 메모리 소비가 효율적입니다.

### 해시 테이블

![](https://res.cloudinary.com/practicaldev/image/fetch/s--A0x8BqVS--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.hashnode.com/res/hashnode/image/upload/v1619693189772/3q-I1nCBt.png)

- 해시 테이블(해시 또는 해시맵)은 데이터를 연상 방식으로 저장하는 데이터 구조입니다. 해시(Hashing)은 해시 함수를 사용하여 key, value를 해시 테이블에 매핑하는 기술입니다. 여기서 "key"는 검색된 문자열이고, "value"는 해당 키와 쌍을 이루는 데이터입니다. 해시 테이블에서 삽입 및 검색 작업은 데이터 크기에 관계없이 매우 빠릅니다. 해시 테이블은 배열을 사용하여 작성됩니다.
  > 해시 함수(Hash function)
  > \: 임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 변환시켜주는 함수입니다. 블록체인에서는 해시 함수는 하는 역할은 '암호화'로, 해시값 비교를 통해서 위변조 여부를 판별하고, 무결성을 검증하는 데 사용됩니다.
- **어디에 해시 테이블이 많이 쓰일까?**
  - Database indexing
  - Caches
  - Unique data representation
  - Lookup in an unsorted array
  - Lookup in sorted array using binary search

### 트리

![](https://camo.githubusercontent.com/56499d1e8aa6a244a4e5a10c761b613d5828131235197e2157829bc606b656c9/68747470733a2f2f7777772e66756e2d636f64696e672e6f72672f30305f496d616765732f747265652e706e67)

- 트리는 노드(node)와 브랜치(branch)를 이용해서, 사이클을 이루지 않도록 구성한 비선형 계층적 데이터 구조입니다. 각 노드에는 일부 데이터와 하위 노드라고 할 수 있는 다른 노드의 링크가 포함되어 있습니다. 트리의 맨 위에 있는 노드를 루트 노드(Root node)라고 합니다. 하위 노드가 연결된 노드를 내부 노드라고 하며, 하위 노드가 없는 노드를 외부 노드(leaf node)라고 합니다.
- 사이클은 위의 이미지를 기준으로 5 - 3 - 6 순으로 원을 그리며 탐색하는 것을 의미합니다.
- 트리 구조에서 Siblings 끼리는 브랜치로 이어지지 않습니다 🔥

#### 이진 트리(Binary Tree)와 이진 탐색트리(Binary Search Tree)

![](https://camo.githubusercontent.com/ed1740faa814d6c595a7a04e9044568f3acba95f53d57de4be9a82626965da37/68747470733a2f2f7777772e6d61746877617265686f7573652e636f6d2f70726f6772616d6d696e672f696d616765732f62696e6172792d7365617263682d747265652f62696e6172792d7365617263682d747265652d696e73657274696f6e2d616e696d6174696f6e2e676966)

    - 이진 트리: 노드의 최대 브랜치가 2개인 트리
      - 이진 트리구조에서 워낙 이진 탐색 트리 형식으로 많이 쓰기 때문에 이진 트리 = 이진 탐색 트리라고 생각하는 경우도 있다
      - 하지만 둘은 같지 않음
      - 이진 트리는 루트 노드의 최대 브랜치가 2개인 트리이며, 사이클을 이루지 않도록 구성한 데이터 구조이지만, 이진 탐색 트리는 해당 이진 트리의 특징을 바탕으로 특정 조건을 붙인 트리이다
      - 이진 탐색 트리: 이진 트리에 다음과 같은 추가적인 조건이 있는 트리
        - 왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드는 해당 노드보다 큰 값을 가지고 있음
      - 자료 구조 이진 탐색 트리의 장점과 주요 용도
        - 주요 용도: 데이터 검색(탐색)
        - 장점: 탐색 속도를 개선할 수 있음

- **알아둘 용어**
  - Node: 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)
  - Root Node: 트리 맨 위(최 상단)에 있는 노드
  - Level: 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄
  - Parent Node: 어떤 노드의 다음 레벨에 연결된 노드
  - Child Node: 어떤 노드의 상위 레벨에 연결된 노드
  - Leaf Node (Terminal Node): Child Node가 하나도 없는 노드
  - Sibling (Brother Node): 동일한 Parent Node를 가진 노드
  - Depth: 트리에서 Node가 가질 수 있는 최대 Level (깊이를 나타냄)
- **어디에 트리가 많이 쓰일까?**

  - 트리 중 이진 트리 (Binary Tree)형태의 구조로, 탐색(검색) 알고리즘 구현을 위해 많이 사용됨

### 그래프

![](https://velog.velcdn.com/images%2Fblackb0x%2Fpost%2Fa78eb70d-d5b4-4143-8d97-34c0ec7c78b5%2Fimage.png)

- 각 노드들이 서로 연결되어 있는 자료 구조입니다. 실제로 그래프 자료 구조 안에 Trees 자료구조가 포함되어 있고, Trees 안에는 Linked List가 포함되어 있습니다. 즉, 그래프는 이들을 모두 포괄하고 있는 자료 구조형입니다.
- 그래프 (Graph) 관련 용어
  - 노드(Node) = 정점(Vertex): 위치를 말함
  - 간선(Edge) = 링크 = 브랜치: 위치 간의 관계를 표시한 선으로 노드를 연결한 선이라고 보면 됨 (link 또는 branch라고도 함)
  - 인접 정점(Adjacent Vertex): 간선으로 직접 연결된 정점(또는 노드)
- 그래프와 트리의 차이

  - **트리는 그래프 중에 속한 특별한 종류라고 볼 수 있음 (트리는 그래프의 한 종류이다)**

    |                | 그래프                                             | 트리                                          |
    | :------------: | :------------------------------------------------- | :-------------------------------------------- |
    |      정의      | 노드와 노드를 연결하는 간선으로 표현되는 자료 구조 | 그래프의 한 종류, 방향성이 있는 비순환 그래프 |
    |     방향성     | 방향 그래프, 무방향 그래프 둘 다 존재함            | 방향 그래프만 존재함                          |
    |     사이클     | 사이클 가능함, 순환 및 비순환 그래프 모두 존재함   | 비순환 그래프로 사이클이 존재하지 않음        |
    |   루트 노드    | 루트 노드 존재하지 않음                            | 루트 노드 존재함                              |
    | 부모/자식 관계 | 부모 자식 개념이 존재하지 않음                     | 부모 자식 관계가 존재함                       |

### 힙

- 힙은 최대힙(Max Heap) 또는 최소힙(Min Heap)으로 구분할 수 있고, 빠른 시간 안에 최대값 또는 최소값을 찾아낼 수 있습니다. 주로 배열을 이용해서 이러한 힙 구조를 구현할 수 있는데, 보통 다른 언어의 경우에는 Heap 구조 자체를 기타 라이브러리를 통해 기본적으로 제공해주는 경우가 많습니다.
  예를 들어, Java의 경우는 PriorityQueue가 있으며, Python3의 경우에는 heapq 라던가 힙 구조화 시켜주는 heapify 함수 등이 있지만, _우리 JS는 당연히 이를 지원해주지 않습니..다..._ 그러나, 외부 라이브러리를 통해 heap을 사용하거나 직접 구현하여 쓸 수 있습니다!

- 자료구조의 힙: 데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리(Complete Binary Tree)
- 완전 이진 트리: 노드를 삽입할 때 최하단의 왼쪽 노드부터 차례대로 삽입하는 트리
- 트리를 기반으로 한 변형된 정책을 쓰고 있다고 생각하면 됨
- js의 실행 컨텍스트에서 객체를 담아두는 공간인 Heap 메모리와 자료구조에서의 Heap은 다름 🔥
- **힙(Heap) 구조**

  - 힙은 최대값을 구하기 위한 구조 (최대 힙, Max Heap)와, 최소값을 구하기 위한 구조 (최소 힙, Min Heap)로 분류할 수 있음
  - 힙은 다음과 같이 두 가지 조건🔥 을 가지고 있는 자료구조임
    1.  각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 같다. (최대 힙의 경우) - 최소 힙의 경우는 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 작음
    2.  완전 이진 트리 형태를 가진다

- **힙을 사용하는 이유**
  - 배열에 데이터를 넣고, 최대값과 최소값을 찾으려면 $ O(n) $이 걸린다 (전체를 순회해야 하기 때문)
  - 이에 반해, 힙에 데이터를 넣고, 최대값과 최소값을 찾으면 $ O(log n) $ 이 걸림
  - 우선 순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용됨
    > 시간 복잡도 순서
    > O(1) < O( 𝑙𝑜𝑔𝑛 ) < O(n) < O(n 𝑙𝑜𝑔𝑛 ) < O( 𝑛2 ) < O( 2𝑛 ) < O(n!)

## 내가 뽑은 핵심 질문

1. 자바스크립트의 배열은 다른 언어와 어떻게 다른가요?

   - Java나 C와 같은 언어에서의 배열은 하나의 타입으로 통일되어 있으며, 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열되어 있는 밀집 배열입니다. 하지만 자바스크립트의 배열은 희소 배열입니다. 즉, 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져있지 않을 수도 있습니다. 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우, 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적인 단점을 갖습니다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있습니다.

2. 스택과 큐의 차이점

   - 스택은 LIFO(Last In First Out) 또는 FILO(First In Last Out) 원리를 따르는 선형 데이터 구조입니다. top을 통해서 push, pop을 하면서 삽입과 삭제가 일어나고, DFS나 재귀에서 사용된다.
     반면, 큐는 선입선출 구조이며, 원소의 줄을 세우는 자료구조입니다. 큐는 한 쪽 끝에서 삽입 작업을 하고, 다른 쪽 끝에서 삭제 작업을 진행합니다. 주로 데이터가 입력된 시간 순서대로 처리되어야 하는 경우 사용하고, BFS나 캐시를 구현할 때 사용합니다.

3. 해시테이블(HashTable)에 대해서 설명해주세요.

   - 해시테이블은 효율적인 탐색을 위한 자료구조로 key값을 value에 대응시킵니다. 해시테이블을 구현하기 위해서는 연결 리스트와 해쉬 함수가 필요합니다. 해싱은 임의의 길이의 값을 해쉬 함수를 통해 고정된 크기의 값으로 변환하는 작업을 말하는데, 키 값을 해시 코드로 변환한 후 해당 해시 코드로 배열의 인덱스를 참조하여 값을 찾습니다. 충돌이 발생할 수 있으며, 최악의 경우 O(N), 일반적으로 잘 구현된 경우는 O(1)의 시간 복잡도를 가지게 됩니다. 충돌은 Chaining, Open addressing 등의 방식으로 해결할 수 있습니다.
