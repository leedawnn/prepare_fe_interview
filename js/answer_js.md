## 목차

- 프로그래밍 🔥

  - 프로그래밍이란 뭐라고 생각하나요?
    - 프로그래밍이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션입니다. 0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 정확하고 상세하게 요구를 설명하는 작업이며, 그 결과물이 바로 코드입니다.
  - 컴파일러는 뭐고 인터프리터는 뭔가요? 🔥
    - 사람이 프로그래밍 언어를 사용하여 프로그램을 작성한 후, 컴퓨터가 이해할 수 있는 기계어로 변환하는 일종의 번역기를 이용합니다. 여기서 일종의 번역기를 컴파일러 혹은 인터프리터라고 합니다.
    - 컴파일러와 인터프리터의 차이는 무엇일까요?
      - 컴파일러는 프로그램 전체를 스캔하여 이를 모두 기계어로 번역합니다. 대표적인 언어로 C,C++, JAVA 등이 있습니다. 인터프리터는 컴파일러와 반대로 프로그램 실행 시 한 번에 한 문장씩 번역합니다. 대표적인 언어로 Python, Ruby, Javascript 등이 있습니다.

- 자바스크립트란 🔥

  - 자바스크립트의 특징은 뭐가 있나요?
    - 자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다. 또한 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어입니다.

- 변수 🔥

  - 변수란 무엇인가요?
    - 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말합니다.
  - 식별자란 무엇인가요? 🔥
    - 변수의 이름을 식별자(indentifier)라고도 합니다. 식별자는 변수에만 국한해서 사용하지 않으며 변수, 함수, 클래스 등 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름을 모두 식별자라고 합니다.
  - 변수를 선언한다는 것은 어떤 것을 의미하나요?
    - 변수 선언이란 변수를 생성하는 것을 말합니다. 좀 더 자세히 말하자면 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것입니다.
  - var 키워드는 뭔가요?
    - var 키워드는 뒤에 오는 변수 이름을 새로운 변수로 선언할 것을 지시하는 키워드입니다.
  - 호이스팅이 뭔가요? 🔥🔥
    - 코드가 실행되기 전 변수 정보를 수집하는 과정을 말합니다.
  - var 키워드의 문제점은 무엇이 있나요? 🔥
    - 변수 중복 선언이 허용되기 때문에 의도치 않게 변수값이 재할당되어 변경되는 부작용이 있습니다. 또한 var로 선언을 하면 동시에 undefined로 초기화되어 실제 값이 할당되지 않더라도 undefined를 가지는 문제점이 있습니다.
  - let 키워드는 var 키워드와 어떤 점이 다른가요? 🔥🔥
    - let으로 같은 이름의 변수를 중복 선언하면 SyntaxError가 발생합니다. 또한 var 키워드와 달리 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러가 발생합니다.
  - TDZ 🔥🔥
    - let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없습니다. 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대(TDZ: Temporal Dead Zone)라 부릅니다.
  - const 키워드는 어떤 특징이 있나요? 🔥
    - const 키워드로 선언한 변수는 재할당이 금지되며, 반드시 선언과 동시에 초기화해야합니다. 그렇지 않을 경우 문법 에러(SyntaxError)가 발생합니다.
  - 네이밍 컨벤션은 어떤 것들이 있나요?

    ```javascript
    // 카멜 케이스 (camelCase)
    var firstName;

    // 스네이크 케이스 (snake_case)
    var first_name;

    // 파스칼 케이스 (PascalCase)
    var FirstName;

    // 헝가리언 케이스 (typeHungarianCase)
    var strFirstName; // type + identifier
    var $elem = document.getElementById('myId'); // DOM 노드
    var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
    ```

  - 리터럴이 뭔가요?
    - 리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말합니다.

- 데이터 타입 🔥

  - 데이터 타입의 종류는 어떤 것들이 있나요? 🔥
    - number, string, boolean, undefined, null, symbol, bigInt, 객체 타입(객체, 함수, 배열 등)이 있습니다.
  - 심벌 타입은 뭐죠?
    - 심벌은 ES6에서 추가되었으며 변경 불가능한 원시 타입의 값입니다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이고, 주로 객체의 유일한 프로퍼티 키를 만들기 위해 사용합니다.
  - 데이터 타입은 왜 필요할까요? 🔥

    1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
    2. 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
    3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

- 정적 타이핑이 뭔가요?
  - C나 자바같은 정적 타입언어는 변수를 선언할 때 데이터 타입을 사전에 선언해야하는데 이를 정적 타이핑이라 합니다.
- 동적 타이핑이 뭔가요?

  - 자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않습니다. 변수를 선언하고 할당할 때 타입이 결정(타입 추론)됩니다. 이러한 특징을 동적 타이핑이라 합니다.

- 타입변환과 단축 평가 🔥

  - 명시적 타입 변환이 뭔가요?
    - 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 합니다.
  - 명시적 타입 변환 함수를 예를 들어볼 수 있나요?

    ```javascript
    // 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
    String(1); // -> "1"

    // 2. Object.prototype.toString 메서드를 사용하는 방법
    (1).toString(); // -> "1"

    // 3. 문자열 연결 연산자를 이용하는 방법
    1 + ''; // -> "1"
    ```

- 암묵적 타입 변환이 뭔가요?

  - 개발자의 의도와는 상관없이 표션식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 합니다. 이를 암묵적 타입 변환 또는 강제 타입 변환이라 합니다.

  ```javascript
  var x = 10;
  console.log(typeof (x + '')); // string
  ```

- truthy / falsy 한 값이 뭔가요?

  - 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분합니다.

  ```javascript
  // falsy => 이외의 값들은 다 truthy임.
  false
  undefined
  null
  0, -0
  NaN
  ' '(빈 문자열)
  ```

- 배열 🔥

  - 자바스크립트의 배열은 자료구조의 배열과 같나요?
    - 같지 않습니다. 자료구조에서 말하는 배열은 밀집 배열(배열의 요소는 하나의 데이터 타입으로 통일 되어 있으며 연속적이다)이고, 자바스크립트의 배열은 희소 배열(배열 안에 여러 가지 데이터 타입들이 있으며, 연속적이지 않음)입니다.
  - 배열의 메서드는 어떤 종류가 있나요?

    - 배열 메서드는 크게 두 종류로 나눌 수 있습니다. 1) 원본 배열을 직접 변경하는 메서드 2) 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드. 원본 배열을 직접 변경하는 메서드는 외부 상태를 직접 변경하는 부수효과가 있으므로, 가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하는 편이 좋습니다.

    ```javascript
    Array.isArray 🌟
    Array.prototype.indexOf 🌟
    Array.prototype.push (원본 배열을 변경한다 - 부수효과 o)
    Array.prototype.pop (원본 배열을 변경한다 - 부수효과 o)
    Array.prototype.unshift (원본 배열을 변경한다 - 부수효과 o)
    Array.prototype.shift (원본 배열을 변경한다 - 부수효과 o)
    Array.prototype.concat 🌟
    Array.prototype.splice 🌟 (원본 배열을 변경한다 - 부수효과 o)
    Array.prototype.slice 🌟
    Array.prototype.join 🌟 (원본 배열을 변경한다 - 부수효과 o)
    Array.prototype.reverse 🌟 (원본 배열을 변경한다 - 부수효과 o)
    Array.prototype.fill 🌟 (원본 배열을 변경한다 - 부수효과 o)
    Array.prototype.includes 🌟
    ```

  - 고차 함수에 대해서 아나요?

    - 고차 함수(Higher-Order Function, HOF)는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말합니다.

  - forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?
    - forEach와 map의 공통점은 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다는 것입니다. 하지만 forEach는 언제나 undefined를 반환하고, map은 콜백 함수의 반환값들로 구성된 새로운 배열을 반환합니다. 즉, forEach는 단순히 반복문을 대체하기 위한 고차함수이고, map은 요소값을 다른 값으로 매핑한 새로운 배열을 생성하기 위한 고차함수입니다.

- 객체 리터럴 🔥

  - 자바스크립트에서 객체란 뭘까요?
    - 자바스크립트는 객체 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 '모든 것'이 객체입니다. 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체입니다.
  - 함수와 메서드의 차이점에 대해 알고 계신가요?
    - 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드(method)라 부릅니다.
  - 자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?

    1. 객체 리터럴
    2. Object 생성자 함수
    3. 생성자 함수
    4. Object.create 메서드
    5. 클래스(ES6)

  - 전역 객체에 대해서 아나요?
    - 전역객체는 코드가 실행되기(런타임) 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체입니다.브라우저에서는 window, node.js에서는 global 객체를 의미합니다.

- 원시 값과 객체 비교 🔥

  - 동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유가 있을까요? 🔥

    - 변경가능한 값은 객체 타입값 / 변경 불가능한 값은 원시 타입값 => 이를 나누기 위해서입니다. 원시값을 변수에 저장하면 값이 전달되고, 객체를 변수에 저장하면 주소가 저장됩니다.

  - 값에 의한 전달이 뭔가요? 🔥
    - 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당하는 변수(score)의 원시 값이 복사되어 전달됩니다. 이를 '값에 의한 전달'이라고 합니다.(다른 메모리 공간에 저장됨)
  - 참조에 의한 전달이 뭔가요? 🔥
    - 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달됩니다. 이를 '참조에 의한 전달'이라고 합니다.(참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체이다)

- 함수 🔥

  - 자바스크립트에서 함수를 정의하는 방법은 몇가지가 있나요?
    1. 함수 선언문
    2. 함수 표현식
    3. Function 생성자 함수
    4. 화살표 함수 (ES6)
  - 함수 선언문과 함수 표현식은 어떤 차이가 있나요?

    ```javascript
    // 함수 선언문
    function Func1() {
      console.log('이것이 함수 선언문');
    }

    // 함수 표현식
    const Func2 = function () {
      console.log('이것이 함수 표현식');
    };
    ```

  - 즉시 실행 함수(IIFE)에 대해 알고 있나요? 알고 있다면 아는 내용에 대해 말해보세요
    - 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수 (IIFE, Immediately Invoked Function Expression) 라고 하며, 즉시 실행 함수는 단 한 번만 호출되며 다시 호출할 수 없습니다.

- 스코프 🔥

  - 스코프가 뭔가요? 🔥🔥
    - 스코프는 유효 범위라는 뜻으로, 식별자(변수)가 유효한 범위를 말합니다.
  - 스코프에는 어떤 종류가 있죠? 🔥

    - 스코프는 전역 스코프와 지역 스코프로 구분됩니다. 전역이란 코드의 가장 바깥 영역을 말하며, 전역 변수는 어디서든 참조할 수 있습니다. 지역이란 함수 내부를 말합니다. 지역 변수는 자신의 스코프와 하위 지역 스코프에서 유효합니다.

  - 렉시컬 스코프를 아나요? 안다면 렉시컬 스코프는 무엇을 의미하나요? 🔥

    - 함수를 어디서 '호출' 했는지가 아닌 어디서 '정의' 했는지에 따라 함수의 상위 스코프를 결정하는 것을 렉시컬 스코프(정적 스코프)라고 합니다.

      ```javascript
      var x = 1;

      function foo() {
        var x = 10;
        bar();
      }

      function bar() {
        console.log(x);
      }

      foo(); // ?
      bar(); // ?
      ```

      > 소스코드의 실행에 있어서 foo 함수 내부에서 bar 함수를 '호출' 하더라도, bar 함수는 foo 함수와 동일한 스코프인 전역 스코프에 '정의'되어 있기 때문에 foo 함수 내부의 x=10을 참조할 수 없습니다. **따라서 foo, bar의 호출한 결과는 모두 1로 반환됩니다.** 이러한 자바스크립트의 정적인 스코프 특징을 '렉시컬 스코프', '정적 스코프' 라고 부릅니다.

- 전역 변수로 변수를 선언하면 생기는 문제점은 무엇이 있을까요?

  1. 전역 변수로 선언하게 되면 코드 어디서든 참조하고 할당되어 값이 변경될 수 있습니다. 변수의 유효 범위(스코프)가 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아집니다.
  2. 자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것입니다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있습니다.

- 생성자 함수에 의한 객체 생성 🔥

  - 생성자 함수가 뭔가요?
    - 생성자 함수란 new 연산자와 함께 호출하여 객체를 생성하는 함수를 말합니다. 생성자 함수에 의해 생성된 객체를 인스턴스라고 합니다.
  - 객체 리터럴로 만들 때와는 무슨 차이가 있죠? 왜 생성자 함수를 사용하나요?

    - 객체 리터럴로 만들면 하나의 객체만 생성할 수 있기 때문에 같은 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 비효율적입니다. 이 때 생성자 함수를 통해 객체를 생성한다면 템플릿처럼 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있습니다.

  - 생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요?

    1. 생성자 함수 선언
    2. 인스턴스 생성
    3. 인스턴스 초기화
    4. 인스턴스 반환

    ```javascript
    // 1. 생성자 함수 선언
    function Circle(radius) {
      // 3. 인스턴스 초기화
      this.radius = radius;
      this.getDiameter = function () {
        return 2 * this.radius;
      };
      // 4. 인스턴스 생성시에 생성자 함수를 호출할 때 넣은 인수를 this 바인딩을 통해 프로퍼티에 할당한 뒤, 인스턴스를 반환한다
    }
    // 2. 인스턴스 생성
    const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성
    ```

- 함수와 일급 객체 🔥

  - 일급 객체가 뭔가요?
    다음과 같은 조건을 만족하는 객체를 일급 객체라고 합니다.

    1. 무명의 리터럴로 생성할 수 있다. (함수 이름 없이)
    2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
    3. 함수의 매개변수에 전달할 수 있다.
    4. 함수의 반환 값으로 사용할 수 있다.

  - 자바스크립트에서 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요?
    - 일급 객체로서 함수가 가지는 가장 큰 특징은 일반 객체와 같이 함수의 매개변수에 전달할 수 있으며, 함수의 반환값으로 사용할 수도 있다는 것입니다. 이는 함수형 프로그래밍을 가능케 하는 자바스크립트의 장점 중 하나입니다.
  - 꼬리 질문) 함수형 프로그래밍이 뭔가요? 🔥
    - 순수 함수를 통해 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안전성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 합니다.
  - 꼬리 질문) 순수 함수가 뭔가요? 일반 함수와는 어떤 차이가 있죠? 🔥

    1. 순수 함수: 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 합니다.
    2. 비순수 함수: 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수라고 합니다.

- 프로토타입 🔥

  - 객체지향 프로그래밍은 무엇을 의미하나요? 🔥
    - 객체지향 프로그래밍은 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말합니다.
  - 객체지향 프로그래밍의 특징에 대해 말해볼 수 있나요? 🔥
    1. 추상화 (Abstraciton)
    2. 캡슐화 (Encapsulation)
    3. 상속 (Inheritance)
    4. 다형성 (Polymorphism)
  - 자바스크립트는 객체지향 프로그래밍 언어인가요?
    - 자바스크립트는 객체지향 프로그래밍 뿐만 아니라 명령형, 함수형 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어입니다. 자바스크립트는 프로토타입 기반의 객체지향 프로그래밍입니다.
  - 프로토타입이 뭔가요?
    - 자바스크립트에서 상속을 구현하기 위해 사용됩니다. 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체(Object.prototype)와 연결되어 있습니다. 이것은 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메서드를 상속 받아 사용할 수 있게 합니다. 이러한 부모 객체를 프로토타입 객체 또는 줄여서 프로토타입이라고 합니다.

- strict mode 🔥

  - strict mode가 뭔가요?
    - strict mode는 자바스크립트의 문법을 좀 더 엄격히 적용하여 오류 발생 가능성을 줄입니다.
  - strict mode를 통해 무엇을 예방할 수 있죠?
    1. 암묵적 전역
    2. 변수, 함수, 매개변수의 삭제
    3. 매개변수 이름의 중복

- 빌트인 객체 🔥

  - 빌트인 객체가 뭔가요? 종류는 어떤게 있죠?

    - 개발자가 모든 기능을 구현하지 않고, 편하게 개발할 수 있도록 자바스크립트에서 기본적으로 제공하는 객체입니다. 1) 표준 빌트인 객체 2)호스트 객체 3)사용자 정의 객체로 나뉩니다.

      > ① 표준 빌트인 객체
      > 앞서 설명한 자바스크립트에서 기본적으로 제공하는 객체 중 ECMAScript 사양에 정의된 표준 객체. 애플리케이션 전역의 공통 기능을 제공한다. 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공됨. 따라서 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다. new 연산자를 사용하여 표준 빌트인 객체와 결합하여 선언하면, 생성된 인스턴스로 하여금 해당 함수에 내장된(빌트인 된) 프로토타입 메서드들을 이용할 수 있다.
      > ② 호스트 객체
      > ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경(브라우저 또는 Node.js 환경)에서 추가로 제공하는 객체를 말한다.
      > 브라우저 환경에서는 DOM, BOM, CANVAS, XMLHttpRequest, fetch, Web Storage, Web Component와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공한다.
      > ③ 사용자 정의 객체
      > 사용자 정의 객체는 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다.

  - 래퍼 객체에 대해서 알고 있나요?

    - 레퍼(wrapper)객체는 원시 타입의 값을 감싸는 형태의 객체입니다. 우리가 문자열의 프로퍼티에 접근하려고 할 때 자바스크립트는 new String을 호출한 것처럼 문자열 값을 객체로 변환합니다. 이 객체를 래퍼 객체라고 하며, 프로퍼티 참조가 끝나면 사라집니다.

    ```javascript
    var str = 'abcde';
    str.len = 5; // new String(str).len = 5

    console.log(str.len); // undefined
    ```

- this 🔥

  - this가 뭔가요? 🔥
    - this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수입니다.
  - this 바인딩이란? 🔥

    - this 바인딩은 this(키워드로 분류되지만 식별자 역할을 한다)와 this가 가리킬 객체를 연결하는 것을 말합니다.

  - this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나요?
    |함수 호출 방식|this 바인딩|
    |------|---|
    |일반 함수 호출|전역 객체(window/ global)|
    |콜백 함수 호출|전역 객체(window/ global)|
    |내부 함수 호출|전역 객체(window/ global)|
    |메서드 호출|메서드를 호출한 객체|
    |생성자 함수 호출|생성자 함수가 (미래에) 생성할 인스턴스 |
    |Function.prototype.apply/call/bind 메서드에 의한 간접 호출|Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |

- 실행 컨텍스트 🔥

  - 실행 컨텍스트에 대해 말해보세요 🔥🔥
    - 실행 컨텍스트는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리됩니다. 실행 컨텍스트는 ①실행 컨텍스트 스택과 ②렉시컬 환경으로 구성되어 있습니다.
      > ① 실행 컨텍스트 스택은 코드의 실행 순서를 관리하는 자료구조로, L.I.F.O(Last In First Out) 구조로 들어오는 코드를 관리한다.
      > ② 렉시컬 환경은 모든 식별자와 바인딩된 값, 스코프를 기록 및 관리하는 자료구조이다. 즉, 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체다.

- 클로저 🔥

  - 클로저에 대해서 아나요? 🔥🔥
    - 함수를 선언할 때 만들어지는 유효범위가 사라진 후(실행 컨텍스트 스택에서 푸시되더라도 렉시컬 환경에 남아)에도 호출할 수 있는 함수를 말합니다.
  - 클로저를 사용하면 뭐가 좋죠? 🔥

    - 클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용합니다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하고 특정 함수에게만 상태변경을 허용하기 위해 사용합니다.

  - 클로저를 어떻게 생성하나요? 🔥
    - 내부(중첩) 함수가 익명 함수로 되어 외부 함수의 반환값으로 사용될 때
    - 내부(중첩) 함수가 외부 함수의 스코프에서 실행될 때
    - 내부 함수에서 사용되는 변수가 외부 함수의 변수 스코프에 포함되어 있을 때

- 클래스 🔥

  - 자바스크립트에서 클래스가 생기기 전에는 어떤 방식으로 객체지향 패턴을 구현했나요?
    - 자바스크립트는 프로토타입 기반 객체지향 언어로서, 클래스가 필요 없는 객체지향 프로그래밍 언어입니다. 이에 어려움을 느끼는 객체지향 프로그래밍에 익숙한 프로그래머들을 위해 ES6부터 클래스 개념을 도입되었습니다.
  - 그럼 생성자 함수와 클래스는 어떤 차이가 있나요?
    - 클래스를 new 연산자 없이 호출하면 에러가 발생하지만, 생성자 함수는 일반 함수로 호출됩니다. 또한 클래스는 상속을 지원하는 extends와 super 키워드를 제공하고, 생성자 함수는 해당 키워드를 제공하지 않습니다.
  - 클래스 정의

    ```javascript
    // 클래스 선언문
    class Person {}

    // 함수 선언문으로 작성시, 함수 호이스팅이
    // 함수 표현식으로 작성시, 변수 호이스팅이 발생한다.
    ```

  - 클래스의 상속
    - 프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장(extends)하여 정의하는 것입니다.

- 스프레드 문법 🔥

  - spread 문법이 뭔가요?
    - 하나로 뭉쳐 있는 여러 값들을 펼쳐서 개별적인 값들의 목록으로 만듭니다. (배열 상태가 아닌 개별적인 값들의 목록 상태이다)
  - 어떤 상황에서 사용할 수 있죠?
    - 배열이나 객체 내부에서 사용할 수 있습니다.

- 구조 분해 할당 🔥

  - 구조 분해 할당이 뭔가요?
    - 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다. 배열과 같은 이터러블 또는 객체 리터럴에서 필요한 값만 추출하여 변수에 할당할 때 유용합니다.
  - 구조 분해 할당은 크게 어떤 종류가 있나요?

    1. 배열 구조분해 할당(배열 디스트럭처링 할당)

    ```javascript
    const arr = [1, 2, 3];

    const [one, two, three] = arr; // 배열 구조 분해 할당의 대상은 이터러블해야하며, 순서대로 할당됨.
    ```

    2. 객체 구조분해 할당(객체 디스트럭처링 할당)

    ```javascript
    var user = { age: 25, name: 'junhee' };

    var { age, name } = user;

    /*
    var { age: age, name: name} = user 와 같은 의미 (프로퍼티 축약 표현)
    */

    console.log(age, name); // 25 junhee
    ```

- 브라우저 렌더링 과정 🔥

  - 브라우저의 렌더링 과정에 대해 설명해보세요 🔥

    1. 클라이언트에서 불러오고 싶은 파일을 서버에 요청한다.
       - 클라이언트에서 요청한 URI를 DNS를 통해 IP 주소로 변환하고, 해당 IP를 가진 서버에 GET 요청을 보내게 된다.
    2. 서버에서 응답으로 받은 HTML 데이터를 파싱한다.(바이트 > 문자 > 토큰 > 노드 > DOM)
    3. HTML 마크업을 바탕으로 DOM 트리를 생성한다.
    4. CSS 마크업을 바탕으로 CSSOM 트리를 생성한다. (바이트 > 문자 >토큰 > 노드 > CSSOM)
    5. DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 형성한다.
    6. 렌더 트리에서 레이아웃을 실행한다.
       - 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 계산한다.
    7. 개별 노드를 화면에 페인트한다.
       - 이후 레이아웃을 바탕으로 브라우저 화면에 픽셀을 렌더링하는 페인팅(painting)처리에 입력되면 렌더링이 완료된다.

  - 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요? 🔥
    1. 렌더링 엔진이 HTML을 한 줄씩 순차적으로 파싱하여 DOM을 생성해 나가다가 `<script>`태그를 만나면 DOM 생성을 일시 중단한다.
    2. 그리고 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘긴다. 이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘겨 HTML 파싱을을 시작하여 DOM 생성을 재개한다.
    3. 자바스크립트 파싱과 실행은 브라우저 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. 자바스크립트 엔진은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할을 한다.
    4. 자바스크립트 엔진은 자바스크립트를 해석하여 AST(Abstact Syntax Tree: 추상적 구문 트리)를 생성한다. 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.
    5. 리플로우와 리페인트
       - 만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM이나 CSSOM이 변경된다.
       - 이때 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우(reflow), 리페인트(repaint)라 한다.
  - `<script></script>` 태그를 `<body></body>` 태그 밑에 둬야하는 이유가 있을까요?
    - 자바스크립트 엔진은 위에서부터 차례대로 코드를 실행합니다. `<script>`태그가 `<body>`태그보다 위에 생성되어 있다면, 에러가 발생할 수 있다. 예를 들면, apple이라는 id를 가진 요소에 색깔을 노란색으로 바꾼다고 해보자. 차례대로 실행했을 때 아직 id가 apple인 HTML 요소를 파싱하지 않았기 때문에 오류가 발생한다.
  - async/defer에 대해서 설명해주세요.
    - ① async ② defer 어트리뷰트는 src 어트리뷰트를 통해 외부 자바스크립트 파일을 로드하는 경우에만 사용할 수 있습니다. ① async은 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 진행됩니다. 단, 자바스크립트 파일의 로드가 완료된 직후 실행하며 이때 HTML 파싱은 중단됩니다. ② defer 또한 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 진행되는데, 자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후 진행됩니다.

- DOM 🔥

  - DOM이 뭔가요?
    - DOM은 HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API를 제공하는 트리 자료구조입니다.
  - DOM을 구성하는 건 뭐가 있나요?
    - DOM은 노드 객체의 계층적인 구조로 구성됩니다. 노드 객체는 12개의 종류가 있으며 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드 등이 있습니다.

- 이벤트 🔥

  - 마우스 이벤트 타입에는 뭐가 있나요? click 말고 클릭을 대체할 수 있는 이벤트가 있나요?
    - mousedown(마우스 버튼을 누르고 있을 때), mouseup(누르고 있던 마우스 버튼을 뗄 때) 등이 있습니다. 클릭을 대체할 수 있는 이벤트로는 mouseup 등을 사용하면 될 것 같습니다.
  - 그 외에 알고 있는 대표적인 이벤트가 있나요?
    - foucs나 submit, change를 많이 사용하는 것 같습니다.
  - 이벤트 핸들러를 등록하는 방식에는 어떤 것들이 있나요?
    1. 이벤트 핸들러 어트리뷰트 방식
    2. 이벤트 핸들러 프로퍼티 방식
    3. addEventListener 메서드 방식
  - 이벤트 전파(propagation)에 대해서 알고 있나요?
    - DOM 트리상에 존재하는 노드에서 발생한 이벤트는 DOM 트리를 통해 전파됩니다. 이를 이벤트 전파라고 합니다.
      > - 캡처링 단계 : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
      > - 타깃 단계 : 이벤트가 이벤트 타깃에 도달
      > - 버블링 단계: 이벤트가 하위 요소에서 상위 요소 방향으로 전파
  - 이벤트 위임(delegation)에 대해서 알고있나요? 🔥
    - 연속되는 태그에 대해서 공통적으로 이벤트를 줘야할 때 우리가 이벤트를 바인딩할 해당 요소의 부모 요소에게 이를 위임하여 이벤트를 진행하는 것을 말합니다.
  - e.preventDefault 에 대해 알고 있나요?
    - e.preventDefault 메서드는 요소 태그의 기본 동작을 중단합니다.
  - e.stopPropagation
    - e.stopPropagation 메서드는 이벤트 전파를 중지시키는 메서드입니다.

- 타이머 🔥

  - 호출 스케쥴링이 무엇인가요?
    - 타이머 함수를 사용하여 명시적으로 호출하지 않고, 일정 시간 이후에 호출되도록 함수 호출을 예약하는 것을 호출 스케쥴링이라고 합니다.
  - 타이머 함수에는 어떤 것들이 있나요?
    1. setTimeout / clearTimeout
       - setTimeout 함수로 생성한 타이머는 1번 동작합니다. setTimeout 함수가 반환한 타이머 id를 clearTimeout 함수의 인수로 전달하여 타이머를 취소할 수 있습니다.
    2. setInterval / clearInterval
       - setInterval 함수는 두번째 인수로 전달받은 시간(ms, 1/1000초)으로 반복 동작하는 타이머를 생성합니다.
  - 이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우에 할 수 있는 어떤 일을 통해 해결할 수 있나요?
    - 디바운스와 쓰로틀을 사용하여 이벤트가 과도하게 호출되는 것을 막거나 조절할 수 있습니다.
      > scroll, resize, mousemove 같은 이벤트는 짧은 시간 간격으로 연속해서 발생한다. 이러한 이벤트에 바인딩한 이벤트 핸들러는 과도하게 호출되어 성능에 문제를 일으킬 수 있다.
  - 디바운스에 대해서 알고 있나요?
    - 디바운스(debounce)는 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 하는 기법입니다.
  - 쓰로틀에 대해서 알고 있나요?
    - 쓰로틀(throttle)은 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 하는 기법입니다. 쓰로틀은 scroll 이벤트 처리나 무한 스크롤 UI 구현 등에 유용하게 사용됩니다.

- 비동기 프로그래밍 🔥

  - 동기와 비동기의 차이점에 대해서 설명해줄 수 있나요? 🔥
    - 현재 실행중인 태스크가 종료될 때까지 다음에 실행될 태스크가 대기하는 방식을 동기(synchronous)처리 방식이라고 하며, 현재 실행중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기(asynchronous)처리라고 합니다. 대표적으로 타이머 함수인 1) setTimeout과 setInterval, 2) HTTP 요청 3) 이벤트 핸들러는 비동기 처리 방식으로 동작합니다.
  - 이벤트 루프와 태스크 큐(매크로태스크 큐)에 대해서 알고 있나요? 🔥🔥
    - 이벤트 루프는 싱글스레드 기반으로 동작하는 자바스크립트에서 함수들을 비동기적으로 실행할 수 있게 합니다.
    - 태스크 큐는 setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역입니다.
  - 마이크로태스크 큐에 대해서 알고 있나요? 🔥
    - 마이크로태스크 큐는 태스크 큐와 별도의 큐로 프로미스 후속 처리 메서드(then/catch/finally)의 콜백 함수가 일시 저장됩니다.
  - 태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요? 🔥
    - 마이크로태스크 큐는 태스크 큐보다 우선순위가 높습니다. 따라서 이벤트 루프에서 마이크로태스크 큐에 쌓인 태스크를 먼저 콜 스택에 올려준 뒤, 태스크 큐에 잔여 태스크를 콜 스택에 올립니다.

- Ajax 🔥

  - Ajax가 뭔가요 어떤 것을 담당하고 있죠?
    - Ajax(Asynchronous JavaScript and XML)란 자바스크립트를 사용하여 ① 브라우저가 ② 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말합니다.
  - Ajax를 사용하면 기존 방식과 어떤 차이가 있을까요?
  - JSON 이 뭔가요?
  - JSON이 제공하는 정적 프로토타입 메서드에 대해 몇가지 말해볼 수 있나요?
  - Ajax로 HTTP 요청을 보내기 위해서는 어떤 방법을 사용할 수 있나요?
  - XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요? 🔥

- REST API 🔥

  - REST API가 뭔가요?
    - REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처이고, REST API는 REST를 기반으로 API를 규현한 것을 의미합니다. 더불어, REST의 기본 원칙을 성실히 지킨 서비스 디자인을 `RESTful`이라고 표현합니다.
  - REST API의 구성은 어떤 것이 있나요?
    - REST API는 **1) 자원(resource) - URI(엔드 포인트)**, **2) 행위(verb) - HTTP 요청 메서드**, **3) 표현(representations) - 페이로드** 이렇게 3가지 요소로 구성됩니다.
  - REST API를 설계하는데 중요한 것이 있을까요?

    1. URI는 리소스를 표현해야하며, 이름은 동사보다는 명사를 사용한다.
    2. 행위에 대한 정의는 HTTP 요청 메서드를 통해 해야한다.

    ```text
    # bad
    GET /getTodos/1
    GET /todos/show/1

    # good

    GET /todos/1
    ```

- HTTP 요청 메서드에 대해서 아는대로 얘기해보세요
  1. GET : 모든/특정 리소스를 가져올 때
  2. POST : 리소스를 생성
  3. PUT : 리소스의 전체 교체
  4. PATCH : 리소스 일부 수정
  5. DELETE : 모든/특정 리소스 삭제
- HTTP 상태 코드를 아는대로 말해주세요 🔥

  - 200 : 요청이 성공적으로 보내졌음을 의미
  - 400 : 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미
  - 401 : 비인증(Unathorize)된 요청을 의미
  - 403 : 콘텐츠에 접근할 권리가 없을 때
  - 404 : URL이 잘못되었을 때
  - 500 : 서버가 처리 방법을 모르는 상황을 의미

- Promise 🔥

  - 콜백이란 뭐라고 생각하나요? 🔥
    - 자바스크립트에서 콜백 함수는 다른 함수의 매개변수로 함수를 전달하고, 어떠한 이벤트가 발생한 후 매개변수로 전달한 함수가 다시 호출되는 것을 의미합니다. 비동기 방식의 함수라고 할 수 있습니다.
  - 프로미스가 뭔가요? 🔥
    - Promise 객체는 ES6에서 도입된 비동기 처리에서 사용되는 객체. 주로 서버에서 받아온 데이터를 화면에 표시하기 위해서 사용하며 데이터를 받아오기도 전에 데이터를 화면에 표시하려고 하면 오류가 발생하거나 빈 화면이 뜨게 되는데, 이러한 문제를 해결하기 위한 방법 중 하나이다.
  - 프로미스 생성 방법
    - Promise 생성자 함수를 new 연산자와 함께 호출하면 프로미스(Promise 객체)를 생성합니다. Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받습니다.
      ```javascript
      const promise = new Promise((resolve, reject) => {
        if (/* 비동기 처리 성공 */) {
          resolve('result');
        } else { /* 비동기 처리 실패 */
          reject('failure reason');
        }
      });
      ```
  - 프로미스의 상태를 나타내는 것은 어떤 것들이 있나요? 🔥

    - Pending(대기): 비동기 처리 로직이 아직 완료되지 않은 상태
    - Fulfilled(이행): 비동기 처리가 완료되어 프로미스가 결과 값을 반환해 준 상태(resolve)
    - Rejected(실패): 비동기 처리가 실패하거나 오류가 발생한 상태(reject)

  - 프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요? 🔥

    - Promise.all : Promise.all 메서드는 여러 개의 비동기 처리를 모두 병렬처리할 때 사용합니다.

      ```javascript
      const requestData1 = () => new Promise((resolve) => setTimeout(() => resolve(1), 3000));
      const requestData2 = () => new Promise((resolve) => setTimeout(() => resolve(2), 2000));
      const requestData3 = () => new Promise((resolve) => setTimeout(() => resolve(3), 1000));

      Promise.all([requestData1(), requestData2(), requestData3()])
        .then(console.log) // [ 1, 2, 3 ] ⇒ 약 3초 소요
        .catch(console.error);
      ```

- 제너레이터와 async await 🔥

  - 제너레이터란 뭔가요? 일반 함수와는 어떤 차이가 있죠?
    - ES6에서 도입된 제너레이터(generator)는 코드 블록의 실행을 일시 중지 (블로킹) 했다가 필요한 시점에 재개할 수 있는 특수한 함수입니다.
  - 제너레이터의 구조

    - 제너레이터는 1) yield 키워드를 이용하여 함수 호출자에게 제어권을 양도(yield)하여 필요한 시점에 함수 실행을 재개할 수 있고, 2) next 메서드를 통해 제너레이터를 실행할 경우, 코드 블록 내에 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 리절트 객체형식으로 반환합니다.

  - async/await 가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠? 🔥
    - async/await는 프로미스를 기반으로 동작하기 때문에 프로미스의 then/catch/finally 등과 같은 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있습니다.
  - Promise와 async/await의 차이점 한 줄 요약 🔥
    - Promise를 활용할 때는 catch문을 통해 에러 핸들링을 해야 하지만, async/await는 try/catch 문을 통해 에러 처리를 할 수 있습니다. 또한 Promise는 then으로 받아올 때 콜백 지옥과 같이 코드가 더러워지기 쉽지만, async/await를 사용하면 가독성이 더 좋습니다.

- 에러 🔥

  - 에러처리를 왜 해야 하나요?
    - 소프트웨어의 비정상적인 동작에 대한 큰 사고로 이어지지 않도록 예방하기 위함입니다. 서비스 운영에 있어서는 사용자들이 서비스를 비정상적으로 사용하는 부분이 있는지 감지를 할 수 있습니다.
  - 자바스크립트에서 에러를 처리하는 방법에는 뭐가 있을까요?
    1. try/catch/finally
    2. Error 객체
    3. throw 문

- 모듈 🔥

  - 모듈이 뭔가요?
    - 모듈(module)이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말합니다.

## 내가 뽑은 핵심 질문

1. REST API에 대해 설명해주세요.
   - 먼저, REST란 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처입니다. REST API는 이러한 REST를 기반으로 API를 구현한 것을 의미합니다. 더불어 REST의 기본 원칙을 성실히 지킨 서비스 디자인을 `RESTful`이라고 표현합니다.
2. Promise가 뭔가요?
   - Promise 객체는 ES6에서 도입된 비동기 처리에서 사용되는 객체 입니다. 주로 서버에서 받아온 데이터를 화면에 표시하기 위해서 사용하며 데이터를 받아오기도 전에 데이터를 화면에 표시하려고 하면 오류가 발생하거나 빈 화면이 뜨게 되는데, 이러한 문제를 해결하기 위한 방법 중 하나이다.
3. 동기와 비동기의 차이점
   - 현재 실행중인 태스크가 종료될 때까지 다음에 실행될 태스크가 대기하는 방식을 동기(synchronous)처리 방식이라고 하며, 현재 실행중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기(asynchronous)처리라고 합니다. 대표적으로 타이머 함수인 setTimeout과 setInterval, 이벤트 핸들러는 비동기 처리 방식으로 동작합니다.
4. 브라우저의 렌더링 과정

   ```text
   1. 클라이언트에서 불러오고 싶은 파일을 서버에 요청한다.
      - 클라이언트에서 요청한 URI를 DNS를 통해 IP 주소로 변환하고, 해당 IP를 가진 서버에 GET 요청을 보내게 된다.
   2. 서버에서 응답으로 받은 HTML 데이터를 파싱한다.(바이트 > 문자 > 토큰 > 노드 > DOM)
   3. HTML 마크업을 바탕으로 DOM 트리를 생성한다.
   4. CSS 마크업을 바탕으로 CSSOM 트리를 생성한다. (바이트 > 문자 >토큰 > 노드 > CSSOM)
   5. DOM 트리와 CSSOM 트리를 결합하여 렌더 트리를 형성한다.
   6. 렌더 트리에서 레이아웃을 실행한다.
      - 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 계산한다.
   7. 개별 노드를 화면에 페인트한다.
      - 이후 레이아웃을 바탕으로 브라우저 화면에 픽셀을 렌더링하는 페인팅(painting)처리에 입력되면 렌더링이 완료된다.
   ```

5. 호이스팅이 뭔가요?
   - JavaScript에서 호이스팅(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미합니다. var로 선언한 변수의 경우 호이스팅 시 undefined로 변수를 초기화합니다. 반면 let과 const로 선언한 변수의 경우 호이스팅 시 변수를 초기화하지 않습니다.
